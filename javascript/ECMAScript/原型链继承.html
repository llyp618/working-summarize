<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Document</title>
</head>
<body>
	<script>
		
		// javascript对象有一个指向原型的链，当试图访问一个对象的属性时，它不仅仅只在该对象上查找，还会继续搜寻该对象的原型，以及原型的原型向上直到末尾。
		// 按照ECMAscript标准，someobject.[[Prototype]] 符号用于指派 someobject的原型。浏览器标准下实现javascript 的 __proto__属性 用于访问原型
		 
		// 例子：
		var obj1 = { a:1 },
				obj2 = {},
				obj3 = {};

		obj2.__proto__ = obj1;

		obj3.__proto__ = obj2;

		console.log(obj3.a);
		// 查找a的过程：  obj3 { } => obj2 {} => obj1 {a:1}; 这就是原型链
		
		// 但是 __proto__在ES6之前未进标准 
		// 
		// 实际开发中我们实现对象创建和生成原型链的方式如下：
		// 
		
		/****  1：普通语法创建对象  *****/
		
		var ary = []; // 等同于 new Array();
		var str = '123'; // new String();





		/****  2：构造函数法 最常用  *****/
		
		function Boy(name){    // 构造函数 constructor  在被new之前 它只是个普通的函数。
			this.name = name;
		};
		Boy.prototype.sex = "male";  //prototype 构造函数的关键属性

		var boy1 = new Boy('lu');    //通过new方法实现继承 将Boy的prototype属性值 写入原型链

		// new方法 的实际行为：
		// var boy1 = new Object();
		// boy1.[[prototype]] = Boy.prototype;
		// Boy.call(boy1)



		/****  3： ES5 的Object.create(); 创建新对象，新对象的原型就是调用create方法时传入的第一个参数  *****/
		var a = {a:1};
		var b = Object.create(a);
		console.log(b.a)
		



		/****  4: ES6 的Class  ****/

	</script>
</body>
</html>